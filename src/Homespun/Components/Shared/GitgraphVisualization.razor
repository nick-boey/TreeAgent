@using Homespun.Features.Gitgraph.Services
@using Microsoft.JSInterop
@inject IGraphService GraphService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="gitgraph-wrapper">
    @if (_isLoading)
    {
        <div class="gitgraph-loading">
            <span class="spinner-border spinner-border-sm" role="status"></span>
            <span>Loading graph...</span>
        </div>
    }
    @if (_error != null)
    {
        <div class="gitgraph-error">
            <span>Failed to load graph: @_error</span>
        </div>
    }
    <div @ref="_containerRef" id="@_containerId" class="gitgraph-container"></div>
</div>

<style>
    .gitgraph-container {
        width: 100%;
        min-height: 400px;
        overflow-x: auto;
        overflow-y: visible;
    }

    .gitgraph-container svg {
        font-family: inherit;
    }

    .gitgraph-loading,
    .gitgraph-error {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem;
        color: var(--text-secondary);
    }

    .gitgraph-error {
        color: var(--status-error);
    }

    /* Node styles */
    .gitgraph-container .node-pr {
        cursor: pointer;
    }

    .gitgraph-container .node-issue {
        cursor: pointer;
    }

    .gitgraph-container .node-selected circle,
    .gitgraph-container .node-selected path {
        filter: drop-shadow(0 0 4px var(--color-ocean));
        stroke-width: 3;
    }

    /* Commit message styles */
    .gitgraph-container text {
        fill: var(--text-primary);
    }

    /* Branch label styles - outline only, no background */
    .gitgraph-container .branch-label rect {
        fill: transparent !important;
        stroke-width: 1px;
    }

    .gitgraph-container .branch-label text {
        fill: inherit;
    }
</style>

@code {
    [Parameter] public required string ProjectId { get; set; }
    [Parameter] public EventCallback<int> OnPullRequestClick { get; set; }
    [Parameter] public EventCallback<string> OnIssueClick { get; set; }
    [Parameter] public string? SelectedNodeId { get; set; }

    private ElementReference _containerRef;
    private string _containerId = $"gitgraph-{Guid.NewGuid():N}";
    private IJSObjectReference? _jsModule;
    private DotNetObjectReference<GitgraphVisualization>? _dotNetRef;
    private bool _isLoading = true;
    private string? _error;
    private GitgraphJsonData? _graphData;
    private int _currentMaxPastPRs = 5;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./Components/Shared/GitgraphVisualization.razor.js");
                _dotNetRef = DotNetObjectReference.Create(this);

                await LoadAndRenderGraph();
            }
            catch (Exception ex)
            {
                _error = ex.Message;
                _isLoading = false;
                StateHasChanged();
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Update selection when SelectedNodeId changes
        if (_jsModule != null && !_isLoading)
        {
            await _jsModule.InvokeVoidAsync("highlightNode", _containerId, SelectedNodeId);
        }
    }

    private async Task LoadAndRenderGraph()
    {
        try
        {
            _graphData = await GraphService.BuildGraphJsonAsync(ProjectId, _currentMaxPastPRs);

            if (_jsModule != null)
            {
                await _jsModule.InvokeVoidAsync("initializeGraph",
                    _containerId,
                    _graphData,
                    _dotNetRef);

                if (SelectedNodeId != null)
                {
                    await _jsModule.InvokeVoidAsync("highlightNode", _containerId, SelectedNodeId);
                }
            }

            _isLoading = false;
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            _isLoading = false;
        }

        StateHasChanged();
    }

    [JSInvokable]
    public async Task LoadMorePastPRs()
    {
        // Increase the limit by 5
        _currentMaxPastPRs += 5;
        await LoadAndRenderGraph();
    }

    [JSInvokable]
    public async Task HandleNodeClick(string nodeType, string nodeId, int? prNumber, string? issueId)
    {
        if (nodeType.Contains("PullRequest") && prNumber.HasValue)
        {
            await OnPullRequestClick.InvokeAsync(prNumber.Value);
        }
        else if (nodeType.Contains("Issue") && issueId != null)
        {
            await OnIssueClick.InvokeAsync(issueId);
        }
    }

    public async Task RefreshAsync()
    {
        if (_jsModule != null)
        {
            await LoadAndRenderGraph();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_jsModule != null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("dispose", _containerId);
                await _jsModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        _dotNetRef?.Dispose();
    }
}
