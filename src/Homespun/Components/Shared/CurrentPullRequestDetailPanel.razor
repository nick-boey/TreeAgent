@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.ClaudeCode.Services
@using Homespun.Features.Git
@using Homespun.Features.GitHub
@using Homespun.Features.Projects
@using Homespun.Features.PullRequests
@using Homespun.Features.PullRequests.Data
@using Homespun.Features.PullRequests.Data.Entities

@inject IClaudeSessionStore SessionStore
@inject IClaudeSessionService SessionService
@inject IAgentStartupTracker StartupTracker
@inject IAgentPromptService AgentPromptService
@inject IRebaseAgentService RebaseAgentService
@inject PullRequestDataService PullRequestDataService
@inject PullRequestWorkflowService PullRequestWorkflowService
@inject ProjectService ProjectService
@inject IGitHubService GitHubService
@inject IGitWorktreeService GitWorktreeService
@inject NavigationManager NavigationManager
@inject ILogger<CurrentPullRequestDetailPanel> Logger

<div class="card pull-request-detail-panel">
    <div class="card-header flex justify-between items-center">
        <span>Pull Request Details</span>
        <button type="button" class="btn-close" @onclick="OnClose"></button>
    </div>
    <div class="card-body">
        <h5 class="card-title">@PullRequest.Title</h5>

        <div class="mb-3">
            <span class="badge @GetStatusBadgeClass()">@PullRequest.Status</span>
            @if (PullRequest.GitHubPRNumber.HasValue)
            {
                <a href="https://github.com/@PullRequest.Project.GitHubOwner/@PullRequest.Project?.GitHubRepo/pull/@PullRequest.GitHubPRNumber"
                   target="_blank"
                   class="badge bg-secondary text-decoration-none ml-1">
                    PR #@PullRequest.GitHubPRNumber
                </a>
            }
            @if (StartupTracker.IsStarting(PullRequest.Id))
            {
                <span class="badge bg-status-warning text-text-primary ml-1">
                    <span class="spinner-border spinner-border-sm mr-1" role="status" style="width: 0.6rem; height: 0.6rem;"></span>
                    Starting...
                </span>
            }
            else if (_session != null)
            {
                <span class="badge bg-status-success ml-1">Session Active</span>
            }
        </div>

        @if (!string.IsNullOrEmpty(PullRequest.Description))
        {
            <p class="card-text">@PullRequest.Description</p>
        }

        <dl class="grid grid-cols-12 text-sm">
            @if (!string.IsNullOrEmpty(PullRequest.BeadsIssueId))
            {
                <dt class="col-span-4">Linked Issue</dt>
                <dd class="col-span-8">
                    <span class="badge bg-status-info text-text-primary">@PullRequest.BeadsIssueId</span>
                </dd>
            }
            @if (!string.IsNullOrEmpty(PullRequest.BranchName))
            {
                <dt class="col-span-4">Branch</dt>
                <dd class="col-span-8"><code>@PullRequest.BranchName</code></dd>
            }
            @if (!string.IsNullOrEmpty(PullRequest.WorktreePath))
            {
                <dt class="col-span-4">Worktree</dt>
                <dd class="col-span-8"><code>@PullRequest.WorktreePath</code></dd>
            }
            <dt class="col-span-4">Created</dt>
            <dd class="col-span-8">@PullRequest.CreatedAt.ToLocalTime().ToString("g")</dd>
            <dt class="col-span-4">Updated</dt>
            <dd class="col-span-8">@PullRequest.UpdatedAt.ToLocalTime().ToString("g")</dd>
        </dl>

        @* Session Status Display *@
        @if (_session != null)
        {
            <div class="border-top pt-3 mt-3">
                <h6>Claude Code Session</h6>
                <div class="mb-2">
                    <span class="badge @GetSessionStatusBadgeClass()">@_session.Status</span>
                    <a href="/session/@_session.Id" class="btn btn-sm btn-outline-primary ml-2">
                        Open Chat
                    </a>
                </div>
                <div class="mb-2">
                    <small class="text-text-muted">
                        Mode: <span class="badge @(_session.Mode == SessionMode.Plan ? "bg-status-info" : "bg-status-success")">@_session.Mode</span>
                    </small>
                    <br/>
                    <small class="text-text-muted">
                        Model: <code>@GetModelDisplayName(_session.Model)</code>
                    </small>
                </div>
                @if (!string.IsNullOrEmpty(_sessionErrorMessage))
                {
                    <div class="alert alert-danger mt-2 mb-0 py-1 px-2 text-sm">@_sessionErrorMessage</div>
                }
            </div>
        }
    </div>
    <div class="card-footer">
        <div class="flex flex-wrap gap-2">
            @* Skip review - only when Ready for Review *@
            @if (PullRequest.Status == OpenPullRequestStatus.ReadyForReview)
            {
                <button class="btn btn-sm btn-outline-warning" @onclick="SkipReview" disabled="@_isLoading">
                    @if (_isLoading)
                    {
                        <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                    }
                    Skip Review
                </button>
            }

            @* Start/Stop Session - available for all statuses *@
            @if (StartupTracker.IsStarting(PullRequest.Id))
            {
                <button class="btn btn-sm btn-secondary" disabled>
                    <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                    Starting Session...
                </button>
            }
            else if (_session != null)
            {
                <a href="/session/@_session.Id" class="btn btn-sm btn-primary">
                    Open Chat
                </a>
                <button class="btn btn-sm btn-outline-danger" @onclick="StopSession" disabled="@_isSessionLoading">
                    @if (_isSessionLoading)
                    {
                        <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                    }
                    Stop Session
                </button>
            }
            else
            {
                <div class="flex flex-col gap-2">
                    <div>
                        <ModelSelector Id="@($"pr-model-{PullRequest.Id}")"
                                       SelectedModel="@_selectedModel"
                                       SelectedModelChanged="OnModelChanged" />
                    </div>
                    <AgentSelector
                        Disabled="@StartSessionDisabled"
                        IsStarting="@StartupTracker.IsStarting(PullRequest.Id)"
                        OnStart="HandleAgentStart" />

                    @if (_worktreeInfo != null && _branchInfo?.BehindCount > 0)
                    {
                        <button class="btn btn-sm btn-outline-warning w-full"
                                @onclick="StartRebaseAsync"
                                disabled="@(_isRebasing || StartupTracker.IsStarting(PullRequest.Id))">
                            @if (_isRebasing)
                            {
                                <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                            }
                            Rebase onto @_project?.DefaultBranch (@_branchInfo.BehindCount behind)
                        </button>
                    }
                </div>
            }

            @* Merge - only when Approved *@
            @if (PullRequest is { Status: OpenPullRequestStatus.Approved, GitHubPRNumber: not null })
            {
                <button class="btn btn-sm btn-primary" @onclick="MergePullRequest" disabled="@_isLoading">
                    @if (_isLoading)
                    {
                        <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                    }
                    Merge
                </button>
            }
        </div>

        @{
            var startupState = StartupTracker.GetState(PullRequest.Id);
        }
        @if (startupState?.Status == AgentStartupStatus.Failed)
        {
            <div class="alert alert-danger mt-2 mb-0 py-1 px-2 text-sm">
                @(startupState.ErrorMessage ?? "Failed to start session")
                <button class="btn btn-link btn-sm p-0 ml-2" @onclick="ClearStartupError">Dismiss</button>
            </div>
        }
        else if (!string.IsNullOrEmpty(_errorMessage))
        {
            <div class="alert alert-danger mt-2 mb-0 py-1 px-2 text-sm">@_errorMessage</div>
        }
        else if (!string.IsNullOrEmpty(_sessionErrorMessage))
        {
            <div class="alert alert-danger mt-2 mb-0 py-1 px-2 text-sm">@_sessionErrorMessage</div>
        }
    </div>
</div>

@code {
    [Parameter] public PullRequest PullRequest { get; set; } = null!;

    [Parameter] public EventCallback OnActionCompleted { get; set; }

    [Parameter] public EventCallback OnClose { get; set; }

    private bool _isLoading;
    private string? _errorMessage;
    private bool _isSessionLoading;
    private string? _sessionErrorMessage;
    private ClaudeSession? _session;
    private string _selectedModel = "opus";
    private Project? _project;
    private WorktreeInfo? _worktreeInfo;
    private BranchInfo? _branchInfo;
    private bool _isRebasing;

    protected override async Task OnParametersSetAsync()
    {
        RefreshSessionStatus();
        await LoadWorktreeInfoAsync();
    }

    private async Task LoadWorktreeInfoAsync()
    {
        _worktreeInfo = null;
        _branchInfo = null;

        // Load project if not already loaded from PullRequest
        _project = PullRequest.Project ?? await ProjectService.GetByIdAsync(PullRequest.ProjectId);

        if (_project == null || string.IsNullOrEmpty(PullRequest.WorktreePath))
            return;

        try
        {
            var worktrees = await GitWorktreeService.ListWorktreesAsync(_project.LocalPath);
            _worktreeInfo = worktrees.FirstOrDefault(w => w.Path == PullRequest.WorktreePath);

            if (_worktreeInfo != null && !string.IsNullOrEmpty(PullRequest.BranchName))
            {
                var branches = await GitWorktreeService.ListLocalBranchesAsync(_project.LocalPath);
                _branchInfo = branches.FirstOrDefault(b => b.ShortName == PullRequest.BranchName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load worktree info for PR {PullRequestId}", PullRequest.Id);
        }
    }

    private void RefreshSessionStatus()
    {
        _session = SessionStore.GetByEntityId(PullRequest.Id);
    }

    private void OnModelChanged(string modelId)
    {
        _selectedModel = modelId;
    }

    private async Task HandleAgentStart(AgentPrompt? selectedPrompt)
    {
        await StartSession(selectedPrompt);
    }

    private async Task StartSession(AgentPrompt? prompt)
    {
        StartupTracker.MarkAsStarting(PullRequest.Id);
        _sessionErrorMessage = null;

        try
        {
            var worktreePath = PullRequest.WorktreePath;

            // If no worktree path, try to create one from the branch
            if (string.IsNullOrEmpty(worktreePath) && !string.IsNullOrEmpty(PullRequest.BranchName) && PullRequest.Project != null)
            {
                Logger.LogInformation("No worktree path for PR, checking if branch {BranchName} has a worktree", PullRequest.BranchName);

                // Check if worktree already exists for this branch
                var worktreeExists = await GitWorktreeService.WorktreeExistsAsync(PullRequest.Project.LocalPath, PullRequest.BranchName);

                if (worktreeExists)
                {
                    // Get the worktree path from existing worktrees
                    var worktrees = await GitWorktreeService.ListWorktreesAsync(PullRequest.Project.LocalPath);
                    var existingWorktree = worktrees.FirstOrDefault(w => w.Branch == PullRequest.BranchName);
                    if (existingWorktree != null)
                    {
                        worktreePath = existingWorktree.Path;
                        Logger.LogInformation("Found existing worktree at {WorktreePath}", worktreePath);

                        // Check if there's already a session running in this worktree
                        var existingSession = SessionStore.GetByEntityId(PullRequest.Id);
                        if (existingSession != null)
                        {
                            _sessionErrorMessage = "A session is already running for this pull request.";
                            StartupTracker.MarkAsFailed(PullRequest.Id, _sessionErrorMessage);
                            return;
                        }

                        // Pull latest changes
                        Logger.LogInformation("Pulling latest changes to worktree {WorktreePath}", worktreePath);
                        var pullSuccess = await GitWorktreeService.PullLatestAsync(worktreePath);
                        if (!pullSuccess)
                        {
                            Logger.LogWarning("Failed to pull latest changes, continuing anyway");
                        }
                    }
                }
                else
                {
                    // Create new worktree for the PR branch
                    Logger.LogInformation("Creating worktree for branch {BranchName}", PullRequest.BranchName);
                    worktreePath = await GitWorktreeService.CreateWorktreeAsync(
                        PullRequest.Project.LocalPath,
                        PullRequest.BranchName,
                        createBranch: false); // Branch already exists for PRs
                }

                // Update the PR with the worktree path
                if (!string.IsNullOrEmpty(worktreePath))
                {
                    PullRequest.WorktreePath = worktreePath;
                    await PullRequestDataService.UpdateWorktreePathAsync(PullRequest.Id, worktreePath);
                }
            }

            if (string.IsNullOrEmpty(worktreePath))
            {
                _sessionErrorMessage = "Unable to create or find worktree for this pull request.";
                StartupTracker.MarkAsFailed(PullRequest.Id, _sessionErrorMessage);
                return;
            }

            // Use the prompt's mode, or default to Build if no prompt selected
            var mode = prompt?.Mode ?? SessionMode.Build;

            var systemPrompt = GenerateSystemPrompt();
            _session = await SessionService.StartSessionAsync(
                PullRequest.Id,
                PullRequest.ProjectId,
                worktreePath,
                mode,
                _selectedModel,
                systemPrompt);

            StartupTracker.MarkAsStarted(PullRequest.Id);

            // Send an initial message to start the agent working (if a prompt is selected)
            if (prompt != null && !string.IsNullOrEmpty(prompt.InitialMessage))
            {
                var context = new PromptContext
                {
                    Title = PullRequest.Title,
                    Id = PullRequest.GitHubPRNumber?.ToString() ?? PullRequest.Id,
                    Description = PullRequest.Description,
                    Branch = PullRequest.BranchName ?? string.Empty,
                    Type = "PullRequest"
                };
                var initialMessage = AgentPromptService.RenderTemplate(prompt.InitialMessage, context);
                if (!string.IsNullOrEmpty(initialMessage))
                {
                    await SessionService.SendMessageAsync(_session.Id, initialMessage);
                }
            }

            // Navigate to the session chat page
            NavigationManager.NavigateTo($"/session/{_session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start session for PR {PullRequestId}", PullRequest.Id);
            StartupTracker.MarkAsFailed(PullRequest.Id, ex.Message);
            _sessionErrorMessage = $"Failed to start session: {ex.Message}";
            _session = null;
        }
    }

    private string? GenerateSystemPrompt()
    {
        // Build a context-aware system prompt based on the pull request
        var sb = new System.Text.StringBuilder();
        sb.AppendLine($"You are working on PR: {PullRequest.Title}");

        if (!string.IsNullOrEmpty(PullRequest.Description))
        {
            sb.AppendLine();
            sb.AppendLine("PR Description:");
            sb.AppendLine(PullRequest.Description);
        }

        if (!string.IsNullOrEmpty(PullRequest.BranchName))
        {
            sb.AppendLine();
            sb.AppendLine($"Branch: {PullRequest.BranchName}");
        }

        if (!string.IsNullOrEmpty(PullRequest.BeadsIssueId))
        {
            sb.AppendLine();
            sb.AppendLine($"Linked Issue: {PullRequest.BeadsIssueId}");
        }

        return sb.ToString();
    }

    private async Task StopSession()
    {
        if (_session == null) return;

        _isSessionLoading = true;
        _sessionErrorMessage = null;
        try
        {
            await SessionService.StopSessionAsync(_session.Id);
            _session = null;
            StartupTracker.Clear(PullRequest.Id);
            await OnActionCompleted.InvokeAsync();
        }
        catch (Exception ex)
        {
            _sessionErrorMessage = ex.Message;
        }
        finally
        {
            _isSessionLoading = false;
        }
    }

    private async Task StartRebaseAsync()
    {
        if (_project == null || _worktreeInfo == null || string.IsNullOrEmpty(PullRequest.BranchName))
        {
            _errorMessage = "Project or worktree not available.";
            return;
        }

        var entityId = $"rebase-{PullRequest.BranchName}";

        StartupTracker.MarkAsStarting(entityId);
        _isRebasing = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Get recently merged PRs for context
            var recentMergedPRs = await PullRequestWorkflowService.GetMergedPullRequestsWithTimeAsync(_project.Id);
            var recentPRInfos = recentMergedPRs
                .Take(10)
                .Select(pr => pr.PullRequest)
                .ToList();

            var session = await RebaseAgentService.StartRebaseAgentAsync(
                _project.Id,
                _worktreeInfo.Path,
                PullRequest.BranchName,
                _project.DefaultBranch,
                _selectedModel,
                recentPRInfos);

            StartupTracker.MarkAsStarted(entityId);

            // Navigate to the session
            NavigationManager.NavigateTo($"/session/{session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start rebase agent for PR {PullRequestId}", PullRequest.Id);
            StartupTracker.MarkAsFailed(entityId, ex.Message);
            _errorMessage = $"Failed to start rebase agent: {ex.Message}";
        }
        finally
        {
            _isRebasing = false;
            StateHasChanged();
        }
    }

    private void ClearStartupError()
    {
        StartupTracker.Clear(PullRequest.Id);
    }

    // Session can be started if there's a branch name and not already starting
    private bool StartSessionDisabled => string.IsNullOrEmpty(PullRequest.BranchName) || StartupTracker.IsStarting(PullRequest.Id);

    private async Task SkipReview()
    {
        _isLoading = true;
        _errorMessage = null;
        try
        {
            // Move back to InDevelopment so session can continue working
            await PullRequestDataService.UpdateStatusAsync(PullRequest.Id, OpenPullRequestStatus.InDevelopment);
            await OnActionCompleted.InvokeAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task MergePullRequest()
    {
        if (!PullRequest.GitHubPRNumber.HasValue)
        {
            _errorMessage = "No GitHub PR linked to this pull request.";
            return;
        }

        _isLoading = true;
        _errorMessage = null;
        try
        {
            // Stop session if running before merge
            if (_session != null)
            {
                await SessionService.StopSessionAsync(_session.Id);
                _session = null;
            }

            var success = await GitHubService.MergePullRequestAsync(
                PullRequest.ProjectId,
                PullRequest.GitHubPRNumber.Value);

            if (!success)
            {
                _errorMessage = "Failed to merge pull request.";
            }
            else
            {
                // Remove from local tracking after successful merge
                await PullRequestDataService.CompleteAsync(PullRequest.Id);
                await OnActionCompleted.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
        }
        finally
        {
            _isLoading = false;
        }
    }

    private string GetStatusBadgeClass()
    {
        return PullRequest.Status switch
        {
            OpenPullRequestStatus.InDevelopment => "bg-primary",
            OpenPullRequestStatus.ReadyForReview => "bg-warning text-dark",
            OpenPullRequestStatus.HasReviewComments => "bg-danger",
            OpenPullRequestStatus.Approved => "bg-success",
            _ => "bg-secondary"
        };
    }

    private string GetSessionStatusBadgeClass() => _session?.Status.ToBadgeClass() ?? "bg-secondary";

    private static string GetModelDisplayName(string model)
    {
        var parts = model.Split('/');
        return parts.Length > 1 ? parts[1] : model;
    }
}
