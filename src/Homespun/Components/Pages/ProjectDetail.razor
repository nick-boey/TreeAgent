@page "/projects/{Id}"
@page "/projects/{Id}/branches"
@implements IDisposable
@using Fleece.Core.Models
@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.ClaudeCode.Services
@using Homespun.Features.Commands
@using Homespun.Features.Fleece.Services
@using Homespun.Features.Fleece.Models
@using Homespun.Features.Git
@using Homespun.Features.GitHub
@using Homespun.Features.Navigation
@using Homespun.Features.Projects
@using Homespun.Features.PullRequests
@using Homespun.Features.PullRequests.Data
@using Homespun.Features.PullRequests.Data.Entities
@using Homespun.Features.SignalR
@using Microsoft.AspNetCore.SignalR.Client
@inject IProjectService ProjectService
@inject PullRequestDataService PullRequestDataService
@inject PullRequestWorkflowService PullRequestWorkflowService
@inject IFleeceService FleeceService
@inject IFleeceIssuesSyncService FleeceIssuesSyncService
@inject IGitHubService GitHubService
@inject IGitWorktreeService GitWorktreeService
@inject ICommandRunner CommandRunner
@inject IClaudeSessionService SessionService
@inject IAgentStartupTracker StartupTracker
@inject ISignalRUrlProvider SignalRUrlProvider
@inject IBreadcrumbService BreadcrumbService
@inject ILogger<ProjectDetail> Logger
@inject NavigationManager NavigationManager
@rendermode InteractiveServer

<PageTitle>@(_project?.Name ?? "Project")</PageTitle>

@if (_project == null)
{
    <p>Loading...</p>
}
else
{
    <div class="flex justify-between items-center mb-3">
        <h1>@_project.Name</h1>
        <div class="btn-group">
            <button class="btn btn-outline-secondary btn-sm" @onclick="RefreshData" disabled="@_isRefreshing">
                @if (_isRefreshing)
                {
                    <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                }
                <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
            <a href="projects/@Id/edit" class="btn btn-outline-secondary btn-sm">Edit Project</a>
        </div>
    </div>

    @* Tab Navigation *@
    <ul class="nav nav-tabs mb-3">
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "issues" ? "active" : "")"
               href="/projects/@Id"
               @onclick="SwitchToIssuesTab"
               @onclick:preventDefault>
                <i class="bi bi-kanban me-1"></i>Issues
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "branches" ? "active" : "")"
               href="/projects/@Id/branches"
               @onclick="SwitchToBranchesTab"
               @onclick:preventDefault>
                <i class="bi bi-diagram-2 me-1"></i>Branches
            </a>
        </li>
    </ul>

    @if (_activeTab == "issues")
    {
        <div class="project-layout">
            <div class="timeline-column">
                <TimelineVisualization
                    @ref="_graphVisualization"
                    ProjectId="@Id"
                    OnPullRequestClick="@SelectPullRequestByNumber"
                    OnIssueClick="@SelectIssue"
                    SelectedNodeId="@GetSelectedNodeId()" />
            </div>

        <div class="detail-column">
            @if (_selectedPullRequest != null)
            {
                <CurrentPullRequestDetailPanel PullRequest="_selectedPullRequest"
                                               OnActionCompleted="RefreshData"
                                               OnClose="ClearSelection"/>
            }
            else if (_selectedIssue != null)
            {
                <IssueDetailPanel ProjectId="@Id"
                                  Issue="_selectedIssue"
                                  OnActionCompleted="RefreshData"
                                  OnClose="ClearSelection"/>
            }
            else
            {
                <div class="card">
                    <div class="card-header">Project Info</div>
                    <div class="card-body">
                        <dl class="info-list">
                            <dt>Local Path</dt>
                            <dd><code>@_project.LocalPath</code></dd>
                            <dt>Default Branch</dt>
                            <dd>@_project.DefaultBranch</dd>
                            <dt>Fleece Issues</dt>
                            <dd>
                                <button class="btn btn-sm btn-outline-secondary"
                                        @onclick="SyncFleeceIssuesAsync"
                                        disabled="@_isSyncingFleece">
                                    @if (_isSyncingFleece)
                                    {
                                        <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                        <span>Syncing...</span>
                                    }
                                    else
                                    {
                                        <i class="bi bi-cloud-upload me-1"></i>
                                        <span>Sync Issues</span>
                                    }
                                </button>
                                @if (_fleeceSyncError != null)
                                {
                                    <span class="badge bg-danger ms-2" title="@_fleeceSyncError">Sync failed</span>
                                    <button class="btn btn-sm btn-link p-0 ms-1" @onclick="SyncFleeceIssuesAsync">
                                        Retry
                                    </button>
                                }
                                else if (_lastFleeceSyncResult != null)
                                {
                                    <span class="badge bg-success ms-2">
                                        @(_lastFleeceSyncResult.FilesCommitted > 0
                                            ? $"Synced {_lastFleeceSyncResult.FilesCommitted} files"
                                            : "Up to date")
                                    </span>
                                }
                            </dd>
                            @if (!string.IsNullOrEmpty(_project.GitHubOwner) && !string.IsNullOrEmpty(_project.GitHubRepo))
                            {
                                <dt>GitHub</dt>
                                <dd>
                                    <a href="https://github.com/@_project.GitHubOwner/@_project.GitHubRepo"
                                       target="_blank">
                                        @_project.GitHubOwner/@_project.GitHubRepo
                                    </a>
                                    @if (_isSyncingPRs)
                                    {
                                        <span class="badge bg-status-info ml-2">
                                            <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                                            Syncing...
                                        </span>
                                    }
                                    else if (_tokenMissing)
                                    {
                                        <span class="badge bg-status-warning text-text-primary ml-2"
                                              title="Set GITHUB_TOKEN environment variable">Token missing</span>
                                        <button class="btn btn-sm btn-link p-0 ml-1" @onclick="SyncPullRequestsAsync">
                                            Retry
                                        </button>
                                    }
                                    else if (_syncError != null)
                                    {
                                        <span class="badge bg-status-error ml-2" title="@_syncError">Sync failed</span>
                                        <button class="btn btn-sm btn-link p-0 ml-1" @onclick="SyncPullRequestsAsync">
                                            Retry
                                        </button>
                                    }
                                    else if (_lastSyncResult != null)
                                    {
                                        <span class="badge bg-status-success ml-2"
                                              title="Imported: @_lastSyncResult.Imported, Updated: @_lastSyncResult.Updated, Removed: @_lastSyncResult.Removed">
                                            Synced
                                        </span>
                                        <button class="btn btn-sm btn-link p-0 ml-1" @onclick="SyncPullRequestsAsync">
                                            Refresh
                                        </button>
                                    }
                                </dd>
                            }
                        </dl>

                        @if (IsDebugBuild)
                        {
                            <hr class="my-3" />

                            <div class="flex flex-col gap-2">
                                <button class="btn btn-outline-primary btn-sm"
                                        @onclick="StartTestAgentAsync"
                                        disabled="@_isStartingTestAgent">
                                    @if (_isStartingTestAgent)
                                    {
                                        <span class="spinner-border spinner-border-sm mr-1" role="status"></span>
                                        <span>Starting...</span>
                                    }
                                    else
                                    {
                                        <span>Start Test Agent</span>
                                    }
                                </button>
                                @if (!string.IsNullOrEmpty(_testAgentError))
                                {
                                    <div class="alert alert-danger py-1 px-2 mb-0 text-sm">
                                        @_testAgentError
                                    </div>
                                }
                            </div>
                        }
                    </div>
                </div>
            }
        </div>
    </div>

        <QuickIssueCreateBar ProjectId="@Id"
                             LocalPath="@_project.LocalPath"
                             OnIssueCreated="RefreshData"
                             OnIssueCreatedForEdit="NavigateToIssueEdit"/>
    }
    else if (_activeTab == "branches")
    {
        <WorktreeManagementPanel Project="@_project"
                                 OnDataChanged="RefreshData" />
    }

    @* Fleece Sync Conflict Modal *@
    @if (_showFleeceConflictModal)
    {
        <div class="modal-backdrop fade show" style="background-color: rgba(0,0,0,0.5);"></div>
        <div class="modal fade show d-block" tabindex="-1">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Sync Conflict</h5>
                        <button type="button" class="btn-close" @onclick="HideFleeceConflictModal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="alert alert-warning">
                            <strong>Unable to pull changes from @_project?.DefaultBranch</strong>
                        </div>
                        <p class="small text-muted">@_fleecePullConflict?.ErrorMessage</p>
                        <p>Choose how to resolve this conflict:</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="HideFleeceConflictModal">Cancel</button>
                        <button type="button" class="btn btn-warning"
                                @onclick="HandleFleeceConflictStash"
                                disabled="@_isSyncingFleece">
                            @if (_isSyncingFleece)
                            {
                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                            }
                            Stash Changes
                        </button>
                        <button type="button" class="btn btn-danger"
                                @onclick="HandleFleeceConflictDiscard"
                                disabled="@_isSyncingFleece">
                            @if (_isSyncingFleece)
                            {
                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                            }
                            Discard All Changes
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
}

<style>
    /* ==========================================================================
       Project Layout Grid
       ========================================================================== */
    .project-layout {
        display: grid;
        grid-template-columns: 1fr 300px;
        gap: var(--spacing-md);
        align-items: start;
        padding-bottom: 70px; /* Space for fixed quick-issue-bar */
    }

    @@media (max-width: 900px) {
        .project-layout {
            grid-template-columns: 1fr;
        }

        .detail-column {
            order: -1;
        }
    }

    .timeline-column {
        min-width: 0;
    }

    .detail-column {
        position: sticky;
        top: var(--spacing-md);
    }
</style>

@code {
    [Parameter] public string Id { get; set; } = "";

    private Project? _project;
    private List<PullRequest>? _rootPullRequests;
    private List<FlattenedPR> _flattenedCurrentPRs = [];
    private PullRequest? _selectedPullRequest;
    private string? _selectedPullRequestId;
    private Issue? _selectedIssue;
    private string? _selectedIssueId;
    private bool _isSyncingPRs;
    private bool _tokenMissing;
    private string? _syncError;
    private SyncResult? _lastSyncResult;
    private List<PullRequestWithTime>? _pastPRs;
    private List<Issue>? _openIssues;
    private List<Issue>? _inProgressIssues;
    private TimelineVisualization? _graphVisualization;
    private HubConnection? _hubConnection;
    private bool _isRefreshing;

    // Tab navigation state
    private string _activeTab = "issues";

    // IsDebugBuild property for conditional rendering
#if DEBUG
    private static bool IsDebugBuild => true;
    // Test agent state
    private bool _isStartingTestAgent;
    private string? _testAgentError;
    private const string TestAgentEntityId = "test-agent";
    private const string TestBranchName = "hsp/test";
#else
    private static bool IsDebugBuild => false;
    // Stubs for Release build (never used since IsDebugBuild is false)
    private bool _isStartingTestAgent => false;
    private string? _testAgentError => null;
    private Task StartTestAgentAsync() => Task.CompletedTask;
#endif

    // Fleece sync state
    private bool _isSyncingFleece;
    private string? _fleeceSyncError;
    private FleeceIssueSyncResult? _lastFleeceSyncResult;
    private bool _showFleeceConflictModal;
    private PullResult? _fleecePullConflict;

    private record FlattenedPR(PullRequest PullRequest, int Level);

    protected override async Task OnInitializedAsync()
    {
        // Determine active tab from URL
        var uri = NavigationManager.Uri;
        _activeTab = uri.Contains("/branches") ? "branches" : "issues";

        // Subscribe to agent startup state changes to update UI
        StartupTracker.OnStateChanged += OnStartupStateChanged;

        await LoadData();
        await SetupSignalRConnection();

        // Start sync and load past PRs after project is loaded
        // Using Task.Run to not block the initial render
        if (_project != null)
        {
            _ = Task.Run(async () =>
            {
                await InvokeAsync(async () =>
                {
                    await SyncPullRequestsAsync();
                    await LoadPastPRsAsync();
                });
            });
        }
    }

    private void SwitchTab(string tab)
    {
        if (_activeTab == tab) return;

        _activeTab = tab;
        ClearSelection();

        // Update the URL without causing a full navigation
        var newUrl = tab == "branches"
            ? $"/projects/{Id}/branches"
            : $"/projects/{Id}";
        NavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);
    }

    private void SwitchToIssuesTab() => SwitchTab("issues");
    private void SwitchToBranchesTab() => SwitchTab("branches");

    public void Dispose()
    {
        StartupTracker.OnStateChanged -= OnStartupStateChanged;
        _ = _hubConnection?.DisposeAsync();
    }

    private async void OnStartupStateChanged(string entityId, AgentStartupState state)
    {
        // Re-render when any startup state changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task SetupSignalRConnection()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(SignalRUrlProvider.GetHubUrl("/hubs/agent"))
                .Build();

            // Listen for pull request sync events
            _hubConnection.On<string, SyncResult>("PullRequestsSynced", async (projectId, syncResult) =>
            {
                // Only refresh if this event is for our project
                if (projectId == Id)
                {
                    Logger.LogInformation("Received PullRequestsSynced event for project {ProjectId}", projectId);
                    _lastSyncResult = syncResult;
                    await InvokeAsync(async () =>
                    {
                        await RefreshData();
                        StateHasChanged();
                    });
                }
            });

            await _hubConnection.StartAsync();
            Logger.LogInformation("SignalR connection established for project {ProjectId}", Id);
        }
        catch (Exception ex)
        {
            // SignalR connection can fail when accessing via external hostname that the container can't resolve.
            // This is expected - real-time updates won't work but the page will still function.
            Logger.LogWarning("SignalR connection failed (real-time updates unavailable): {Message}", ex.Message);
        }
    }

    private async Task LoadData()
    {
        _project = await ProjectService.GetByIdAsync(Id);
        if (_project != null)
        {
            // Set breadcrumb context with project info
            await BreadcrumbService.SetContextAsync(new BreadcrumbContext { ProjectId = Id });

            _rootPullRequests = await PullRequestDataService.GetTreeAsync(Id);
            _flattenedCurrentPRs = FlattenPRs(_rootPullRequests ?? []);

            try
            {
                // Load all issues from Fleece
                var allIssues = await FleeceService.ListIssuesAsync(_project.LocalPath);

                // Get open issues (all non-completed statuses)
                _openIssues = allIssues
                    .Where(i => i.Status is IssueStatus.Idea or IssueStatus.Spec or IssueStatus.Next or IssueStatus.Progress or IssueStatus.Review)
                    .ToList();

                // In-progress issues could be tracked separately if needed
                _inProgressIssues = [];
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load issues for project {ProjectId}", Id);
                _openIssues = [];
                _inProgressIssues = [];
            }
        }
    }

    private List<FlattenedPR> FlattenPRs(List<PullRequest> prs, int level = 0)
    {
        var result = new List<FlattenedPR>();
        foreach (var pr in prs.OrderBy(p => p.CreatedAt))
        {
            result.Add(new FlattenedPR(pr, level));
            if (pr.Children.Any())
            {
                result.AddRange(FlattenPRs(pr.Children.ToList(), level + 1));
            }
        }

        return result;
    }

    private async Task LoadPastPRsAsync()
    {
        if (_project == null)
            return;

        var isConfigured = await GitHubService.IsConfiguredAsync(_project.Id);
        if (!isConfigured)
            return;

        try
        {
            var mergedPRs = await PullRequestWorkflowService.GetMergedPullRequestsWithTimeAsync(Id);
            var closedPRs = await PullRequestWorkflowService.GetClosedPullRequestsWithTimeAsync(Id);
            _pastPRs = mergedPRs.Concat(closedPRs).ToList();
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load past PRs for project {ProjectId}", Id);
            _pastPRs = [];
        }
    }

    private async Task SyncPullRequestsAsync()
    {
        if (_project == null || _isSyncingPRs)
            return;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return;

        var isConfigured = await GitHubService.IsConfiguredAsync(_project.Id);
        if (!isConfigured)
        {
            _tokenMissing = true;
            Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
            StateHasChanged();
            return;
        }

        _isSyncingPRs = true;
        _tokenMissing = false;
        _syncError = null;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Starting automatic PR sync for project {ProjectId} ({Owner}/{Repo})",
                _project.Id, _project.GitHubOwner, _project.GitHubRepo);

            _lastSyncResult = await GitHubService.SyncPullRequestsAsync(_project.Id);

            if (_lastSyncResult.Errors.Count > 0)
            {
                _syncError = string.Join("; ", _lastSyncResult.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, _syncError);
            }
            else
            {
                Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                    _project.Id, _lastSyncResult.Imported, _lastSyncResult.Updated, _lastSyncResult.Removed);
            }

            await LoadData();
        }
        catch (Exception ex)
        {
            _syncError = ex.Message;
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingPRs = false;
            StateHasChanged();
        }
    }

    private async Task RefreshData()
    {
        if (_isRefreshing) return;

        _isRefreshing = true;
        StateHasChanged();

        try
        {
            await LoadData();
            if (_selectedPullRequestId != null)
            {
                _selectedPullRequest = await PullRequestDataService.GetByIdAsync(_selectedPullRequestId);
            }
            await _graphVisualization?.RefreshAsync()!;
        }
        finally
        {
            _isRefreshing = false;
            StateHasChanged();
        }
    }

    private async Task NavigateToIssueEdit(string issueId)
    {
        await RefreshData();
        NavigationManager.NavigateTo($"/projects/{Id}/issues/{issueId}/edit");
    }

    private async Task SelectPullRequest(string pullRequestId)
    {
        // Clear any issue selection
        _selectedIssueId = null;
        _selectedIssue = null;

        _selectedPullRequestId = pullRequestId;
        _selectedPullRequest = await PullRequestDataService.GetByIdAsync(pullRequestId);
    }

    private void SelectIssue(string issueId)
    {
        // Clear any pull request selection
        _selectedPullRequestId = null;
        _selectedPullRequest = null;

        _selectedIssueId = issueId;
        _selectedIssue = _openIssues?.FirstOrDefault(i => i.Id == issueId)
                         ?? _inProgressIssues?.FirstOrDefault(i => i.Id == issueId);
    }

    private async Task SelectPullRequestByNumber(int prNumber)
    {
        // Clear any issue selection
        _selectedIssueId = null;
        _selectedIssue = null;

        // Find the PR in current PRs (internal database)
        var currentPr = _flattenedCurrentPRs.FirstOrDefault(p => p.PullRequest.GitHubPRNumber == prNumber);
        if (currentPr != null)
        {
            _selectedPullRequestId = currentPr.PullRequest.Id;
            _selectedPullRequest = await PullRequestDataService.GetByIdAsync(currentPr.PullRequest.Id);
            return;
        }

        // For past PRs, we don't have internal IDs, so clear selection
        // (Past PRs from GitHub API are view-only in the graph)
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
    }

    private string? GetSelectedNodeId()
    {
        if (_selectedPullRequest != null && _selectedPullRequest.GitHubPRNumber.HasValue)
        {
            return $"pr-{_selectedPullRequest.GitHubPRNumber}";
        }

        if (_selectedIssueId != null)
        {
            return $"issue-{_selectedIssueId}";
        }

        return null;
    }

    private void ClearSelection()
    {
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
        _selectedIssueId = null;
        _selectedIssue = null;
    }

    private int GetTotalCurrentPRCount()
    {
        return _flattenedCurrentPRs.Count;
    }

    private int GetTotalCurrentCount()
    {
        return _flattenedCurrentPRs.Count + (_inProgressIssues?.Count ?? 0);
    }

    private static string GetPastPRStatusColor(PullRequestStatus status) => status switch
    {
        PullRequestStatus.Merged => "status-merged",
        PullRequestStatus.Closed => "status-closed",
        _ => "status-default"
    };

    private static string GetCurrentPRStatusColor(OpenPullRequestStatus status) => status switch
    {
        OpenPullRequestStatus.InDevelopment => "status-in-development",
        OpenPullRequestStatus.ReadyForReview => "status-ready-for-review",
        OpenPullRequestStatus.HasReviewComments => "status-has-review-comments",
        OpenPullRequestStatus.Approved => "status-approved",
        _ => "status-default"
    };

    private static string GetIssueTypeStatusColor(IssueType type) => type switch
    {
        IssueType.Feature => "status-feature",
        IssueType.Bug => "status-bug",
        IssueType.Chore => "status-chore",
        IssueType.Task => "status-task",
        _ => "status-default"
    };

    private static string GetIssueStatusColor(Issue issue)
    {
        if (issue.Status == IssueStatus.Closed || issue.Status == IssueStatus.Complete)
            return "status-approved";
        return GetIssueTypeStatusColor(issue.Type);
    }

    private static string GetIssueStatusTooltip(Issue issue)
    {
        return $"{issue.Type} ({issue.Status})";
    }

    private static string? GetPastPRSubtitle(PullRequestInfo pr)
    {
        var parts = new List<string>();

        if (pr.MergedAt.HasValue)
            parts.Add($"Merged {pr.MergedAt.Value:MMM d, yyyy}");
        else if (pr.ClosedAt.HasValue)
            parts.Add($"Closed {pr.ClosedAt.Value:MMM d, yyyy}");

        if (!string.IsNullOrEmpty(pr.Group))
            parts.Add(pr.Group);

        return parts.Count > 0 ? string.Join(" - ", parts) : null;
    }

    private static string? GetCurrentPRSubtitle(PullRequest pr)
    {
        var parts = new List<string>();

        if (!string.IsNullOrEmpty(pr.BranchName))
            parts.Add(pr.BranchName);

        return parts.Count > 0 ? string.Join(" - ", parts) : null;
    }

    private static string? GetIssueSubtitle(Issue issue)
    {
        if (!string.IsNullOrEmpty(issue.Description))
        {
            // Truncate description for subtitle display
            var desc = issue.Description;
            if (desc.Length > 60)
                desc = desc[..57] + "...";
            return desc;
        }

        return null;
    }

    private AgentStartupStatus? GetStartupState(string entityId)
    {
        var state = StartupTracker.GetState(entityId);
        return state?.Status;
    }

    private string? GetStartupErrorMessage(string entityId)
    {
        var state = StartupTracker.GetState(entityId);
        return state?.ErrorMessage;
    }

#if DEBUG
    private async Task StartTestAgentAsync()
    {
        if (_project == null)
            return;

        _isStartingTestAgent = true;
        _testAgentError = null;
        StateHasChanged();

        try
        {
            // Calculate the expected worktree path (same logic as GitWorktreeService)
            var parentDir = Path.GetDirectoryName(_project.LocalPath);
            if (string.IsNullOrEmpty(parentDir))
            {
                _testAgentError = "Cannot determine parent directory of repository.";
                return;
            }
            var expectedWorktreePath = Path.GetFullPath(Path.Combine(parentDir, TestBranchName));

            // Clean up existing worktree and branch if they exist
            Logger.LogInformation("Cleaning up existing test worktree at {WorktreePath}", expectedWorktreePath);

            // Try to remove the worktree first (this handles the git worktree tracking)
            await GitWorktreeService.RemoveWorktreeAsync(_project.LocalPath, expectedWorktreePath);

            // If the directory still exists (e.g., worktree was already pruned), delete it manually
            if (Directory.Exists(expectedWorktreePath))
            {
                Logger.LogInformation("Deleting existing directory at {WorktreePath}", expectedWorktreePath);
                Directory.Delete(expectedWorktreePath, recursive: true);
            }

            // Delete the branch if it exists (force delete to handle unmerged changes)
            await CommandRunner.RunAsync("git", $"branch -D \"{TestBranchName}\"", _project.LocalPath);

            // Prune any stale worktree references
            await GitWorktreeService.PruneWorktreesAsync(_project.LocalPath);

            // Create worktree for hsp/test branch
            var worktreePath = await GitWorktreeService.CreateWorktreeAsync(
                _project.LocalPath,
                TestBranchName,
                createBranch: true,
                baseBranch: _project.DefaultBranch);

            if (string.IsNullOrEmpty(worktreePath))
            {
                _testAgentError = "Failed to create worktree for test branch.";
                return;
            }

            Logger.LogInformation("Created test worktree at {WorktreePath}", worktreePath);

            // Start the agent session without a system prompt
            StartupTracker.MarkAsStarting(TestAgentEntityId);

            var session = await SessionService.StartSessionAsync(
                TestAgentEntityId,
                Id,
                worktreePath,
                SessionMode.Build,
                "sonnet",
                systemPrompt: null);

            StartupTracker.MarkAsStarted(TestAgentEntityId);

            Logger.LogInformation("Started test agent session {SessionId}", session.Id);

            // Send the task instruction as the initial message
            // This way the full instruction is visible in the chat
            var timestamp = DateTime.UtcNow.ToString("O");
            var taskMessage = $"""
                Create a file named `test.txt` in the current directory containing the following timestamp: {timestamp}

                After creating the file, confirm that it was created successfully.
                """;
            await SessionService.SendMessageAsync(session.Id, taskMessage);

            // Agent started - user stays on current page and can monitor via status indicator
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start test agent");
            StartupTracker.MarkAsFailed(TestAgentEntityId, ex.Message);
            _testAgentError = $"Failed to start test agent: {ex.Message}";
        }
        finally
        {
            _isStartingTestAgent = false;
            StateHasChanged();
        }
    }
#endif

    private async Task SyncFleeceIssuesAsync()
    {
        if (_project == null || _isSyncingFleece)
            return;

        _isSyncingFleece = true;
        _fleeceSyncError = null;
        StateHasChanged();

        try
        {
            // Step 1: Commit and push .fleece/ changes
            _lastFleeceSyncResult = await FleeceIssuesSyncService.SyncAsync(
                _project.LocalPath,
                _project.DefaultBranch);

            if (!_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            // Step 2: Pull changes back
            var pullResult = await FleeceIssuesSyncService.PullChangesAsync(
                _project.LocalPath,
                _project.DefaultBranch);

            if (!pullResult.Success && pullResult.HasConflicts)
            {
                _fleecePullConflict = pullResult;
                _showFleeceConflictModal = true;
                return;
            }

            // Step 3: Refresh the graph
            await RefreshData();
        }
        catch (Exception ex)
        {
            _fleeceSyncError = ex.Message;
            Logger.LogError(ex, "Failed to sync fleece issues for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private void HideFleeceConflictModal()
    {
        _showFleeceConflictModal = false;
        _fleecePullConflict = null;
    }

    private async Task HandleFleeceConflictStash()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            var stashSuccess = await FleeceIssuesSyncService.StashChangesAsync(_project.LocalPath);
            if (!stashSuccess)
            {
                _fleeceSyncError = "Failed to stash changes";
                return;
            }

            var pullResult = await FleeceIssuesSyncService.PullChangesAsync(
                _project.LocalPath,
                _project.DefaultBranch);
            if (!pullResult.Success)
            {
                _fleeceSyncError = pullResult.ErrorMessage;
                return;
            }

            HideFleeceConflictModal();
            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictDiscard()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            var discardSuccess = await FleeceIssuesSyncService.DiscardChangesAsync(_project.LocalPath);
            if (!discardSuccess)
            {
                _fleeceSyncError = "Failed to discard changes";
                return;
            }

            var pullResult = await FleeceIssuesSyncService.PullChangesAsync(
                _project.LocalPath,
                _project.DefaultBranch);
            if (!pullResult.Success)
            {
                _fleeceSyncError = pullResult.ErrorMessage;
                return;
            }

            HideFleeceConflictModal();
            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

}
