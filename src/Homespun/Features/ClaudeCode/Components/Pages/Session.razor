@page "/session/{SessionId}"
@using Homespun.ClaudeAgentSdk
@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.ClaudeCode.Services
@using Homespun.Features.ClaudeCode.Hubs
@using Homespun.Features.Shared.Services
@using Homespun.Features.SignalR
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@implements IAsyncDisposable
@rendermode InteractiveServer
@inject IClaudeSessionService SessionService
@inject ISignalRUrlProvider SignalRUrlProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IMarkdownRenderingService MarkdownService

<PageTitle>Session - Homespun</PageTitle>

<div class="session-page">
    @if (_session == null)
    {
        <div class="session-not-found">
            <h2>Session Not Found</h2>
            <p>The session you're looking for doesn't exist or has ended.</p>
            <a href="/agents" class="btn btn-primary">Back to Sessions</a>
        </div>
    }
    else
    {
        <div class="session-header">
            <div class="session-info">
                <h1>Claude Code Session</h1>
                <div class="session-meta">
                    <span class="badge @GetModeBadgeClass(_session.Mode)">@_session.Mode</span>
                    <span class="badge @GetStatusBadgeClass(_session.Status)">@_session.Status.ToDisplayLabel()</span>
                    <code class="model-name">@_session.Model</code>
                </div>
            </div>
            <div class="session-actions">
                <button class="btn btn-outline-danger btn-sm" @onclick="StopSession"
                        disabled="@(_session.Status == ClaudeSessionStatus.Stopped)">
                    Stop Session
                </button>
            </div>
        </div>

        <div class="chat-container">
            <div class="messages-area" @ref="_messagesContainer">
                @if (_session.Messages.Count == 0 && _session.Status != ClaudeSessionStatus.Running)
                {
                    <div class="empty-state">
                        <p>Start the conversation by typing a message below.</p>
                    </div>
                }
                else
                {
                    @foreach (var message in _session.Messages)
                    {
                        <div class="message @(message.Role == ClaudeMessageRole.User ? "user-message" : "assistant-message")">
                            <div class="message-header">
                                <span class="message-role">@(message.Role == ClaudeMessageRole.User ? "You" : "Claude")</span>
                                <span class="message-time">@message.CreatedAt.ToLocalTime().ToString("HH:mm:ss")</span>
                            </div>
                            <div class="message-content">
                                @foreach (var content in message.Content)
                                {
                                    <div class="content-block @GetContentBlockClass(content.Type) @(content.IsStreaming ? "streaming" : "")">
                                        @switch (content.Type)
                                        {
                                            case ClaudeContentType.Text:
                                                <div class="text-content markdown-content">
                                                    @((MarkupString)MarkdownService.RenderToHtml(content.Text))
                                                    @if (content.IsStreaming)
                                                    {
                                                        <span class="streaming-cursor">â–Œ</span>
                                                    }
                                                </div>
                                                break;

                                            case ClaudeContentType.Thinking:
                                                <details class="thinking-block" open="@content.IsStreaming">
                                                    <summary>
                                                        @if (content.IsStreaming)
                                                        {
                                                            <span>Thinking</span>
                                                            <span class="streaming-dots">...</span>
                                                        }
                                                        else
                                                        {
                                                            <span>Thinking...</span>
                                                        }
                                                    </summary>
                                                    <div class="thinking-content">
                                                        @content.Text
                                                        @if (content.IsStreaming)
                                                        {
                                                            <span class="streaming-cursor">â–Œ</span>
                                                        }
                                                    </div>
                                                </details>
                                                break;

                                            case ClaudeContentType.ToolUse:
                                                <div class="tool-use-block">
                                                    <div class="tool-header">
                                                        <span class="tool-icon">ðŸ”§</span>
                                                        <span class="tool-name">@content.ToolName</span>
                                                        @if (content.IsStreaming)
                                                        {
                                                            <span class="tool-streaming-indicator">
                                                                <span class="spinner-border spinner-border-sm ml-2" role="status"></span>
                                                            </span>
                                                        }
                                                    </div>
                                                    @if (!string.IsNullOrEmpty(content.ToolInput))
                                                    {
                                                        <pre class="tool-input">@content.ToolInput@(content.IsStreaming ? "â–Œ" : "")</pre>
                                                    }
                                                </div>
                                                break;

                                            case ClaudeContentType.ToolResult:
                                                <div class="tool-result-block">
                                                    <pre class="tool-result">@content.Text</pre>
                                                </div>
                                                break;
                                        }
                                    </div>
                                }
                            </div>
                        </div>
                    }

                    @if (_session.Status == ClaudeSessionStatus.Running)
                    {
                        <div class="processing-indicator">
                            <div class="spinner-border spinner-border-sm" role="status"></div>
                            <span>Processing...</span>
                        </div>
                    }
                }
            </div>

            <div class="input-area">
                <select class="permission-select"
                        @bind="_selectedPermissionMode"
                        disabled="@(_session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped)">
                    <option value="@PermissionMode.BypassPermissions">Bypass permissions</option>
                    <option value="@PermissionMode.AcceptEdits">Accept edits</option>
                    <option value="@PermissionMode.Plan">Plan</option>
                    <option value="@PermissionMode.Default">Default</option>
                </select>
                <textarea @bind="_inputMessage"
                          @bind:event="oninput"
                          @onkeydown="HandleKeyDown"
                          placeholder="Type a message..."
                          rows="3"
                          disabled="@(_session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped)">
                </textarea>
                <button class="btn btn-primary send-button"
                        @onclick="SendMessage"
                        disabled="@(string.IsNullOrWhiteSpace(_inputMessage) || _session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped)">
                    Send
                </button>
            </div>
        </div>

        @if (_session.TotalCostUsd > 0)
        {
            <div class="session-stats">
                <span>Cost: $@_session.TotalCostUsd.ToString("F6")</span>
                <span>Duration: @FormatDuration(_session.TotalDurationMs)</span>
            </div>
        }

        <!-- Debug Panel -->
        <details class="debug-panel">
            <summary @onclick="ToggleDebugMode" @onclick:preventDefault @onclick:stopPropagation>
                <span>Debug SignalR Events</span>
                @if (_debugMode)
                {
                    <span class="debug-count">(@_debugLog.Count events)</span>
                }
            </summary>
            @if (_debugMode)
            {
                <div class="debug-controls">
                    <button class="btn btn-outline-secondary btn-sm" @onclick="ClearDebugLog">Clear Log</button>
                </div>
                <div class="debug-log">
                    @if (_debugLog.Count == 0)
                    {
                        <div class="debug-empty">No events logged yet. Interact with the session to see SignalR events.</div>
                    }
                    else
                    {
                        @foreach (var entry in _debugLog.AsEnumerable().Reverse().Take(50))
                        {
                            <div class="debug-entry @(entry.EventType == "ERROR" ? "error" : "")">
                                <span class="debug-time">@entry.Timestamp.ToString("HH:mm:ss.fff")</span>
                                <span class="debug-type">@entry.EventType</span>
                                <span class="debug-message">@entry.Message</span>
                            </div>
                        }
                    }
                </div>
            }
        </details>
    }
</div>

<style>
    .session-page {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 100px);
        max-width: 1200px;
        margin: 0 auto;
        padding: var(--spacing-lg);
    }

    .session-not-found {
        text-align: center;
        padding: var(--spacing-xl);
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: var(--spacing-lg);
        padding-bottom: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
    }

    .session-info h1 {
        margin: 0 0 var(--spacing-sm) 0;
        font-size: 1.5rem;
    }

    .session-meta {
        display: flex;
        gap: var(--spacing-sm);
        align-items: center;
    }

    .model-name {
        font-size: 0.875rem;
        padding: 0.25rem 0.5rem;
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
    }

    .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--bg-secondary);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-color);
        overflow: hidden;
    }

    .messages-area {
        flex: 1;
        overflow-y: auto;
        padding: var(--spacing-md);
    }

    .empty-state {
        text-align: center;
        color: var(--text-muted);
        padding: var(--spacing-xl);
    }

    .message {
        margin-bottom: var(--spacing-md);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
    }

    .user-message {
        background: var(--bg-tertiary);
        margin-left: 20%;
    }

    .assistant-message {
        background: var(--bg-primary);
        margin-right: 10%;
        border: 1px solid var(--border-color);
    }

    .message-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: var(--spacing-sm);
        font-size: 0.875rem;
    }

    .message-role {
        font-weight: 600;
    }

    .message-time {
        color: var(--text-muted);
    }

    .content-block {
        margin-bottom: var(--spacing-sm);
    }

    .content-block:last-child {
        margin-bottom: 0;
    }

    .text-content {
        white-space: pre-wrap;
        word-break: break-word;
    }

    .thinking-block {
        background: var(--bg-secondary);
        padding: var(--spacing-sm);
        border-radius: var(--radius-sm);
        font-size: 0.875rem;
    }

    .thinking-block summary {
        cursor: pointer;
        color: var(--text-muted);
    }

    .thinking-content {
        margin-top: var(--spacing-sm);
        white-space: pre-wrap;
        color: var(--text-secondary);
    }

    .tool-use-block, .tool-result-block {
        background: var(--bg-tertiary);
        padding: var(--spacing-sm);
        border-radius: var(--radius-sm);
        font-family: monospace;
        font-size: 0.875rem;
    }

    .tool-header {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        margin-bottom: var(--spacing-xs);
    }

    .tool-name {
        font-weight: 600;
    }

    .tool-input, .tool-result {
        margin: 0;
        padding: var(--spacing-sm);
        background: var(--bg-primary);
        border-radius: var(--radius-sm);
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 200px;
        overflow-y: auto;
    }

    .processing-indicator {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-md);
        color: var(--text-muted);
    }

    /* Streaming content indicators */
    .streaming-cursor {
        animation: blink 1s step-end infinite;
        color: var(--color-lagoon);
    }

    .streaming-dots {
        animation: dots 1.5s ease-in-out infinite;
    }

    .content-block.streaming {
        border-left: 2px solid var(--color-lagoon);
        padding-left: var(--spacing-sm);
    }

    @@keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }

    @@keyframes dots {
        0%, 20% { content: '.'; }
        40% { content: '..'; }
        60%, 100% { content: '...'; }
    }

    .input-area {
        display: flex;
        gap: var(--spacing-sm);
        padding: var(--spacing-md);
        border-top: 1px solid var(--border-color);
        background: var(--bg-primary);
        align-items: flex-start;
    }

    .permission-select {
        flex-shrink: 0;
        padding: var(--spacing-sm);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: inherit;
        font-size: 0.875rem;
        cursor: pointer;
        min-width: 140px;
    }

    .permission-select:focus {
        outline: none;
        border-color: var(--primary);
    }

    .permission-select:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .input-area textarea {
        flex: 1;
        resize: none;
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        padding: var(--spacing-sm);
        font-family: inherit;
        background: var(--bg-secondary);
        color: var(--text-primary);
    }

    .input-area textarea:focus {
        outline: none;
        border-color: var(--color-lagoon);
    }

    .send-button {
        align-self: flex-end;
    }

    .session-stats {
        display: flex;
        gap: var(--spacing-lg);
        padding: var(--spacing-sm) 0;
        font-size: 0.875rem;
        color: var(--text-muted);
    }

    /* Debug Panel Styles */
    .debug-panel {
        margin-top: var(--spacing-md);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-secondary);
    }

    .debug-panel summary {
        padding: var(--spacing-sm) var(--spacing-md);
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .debug-panel summary:hover {
        color: var(--text-primary);
    }

    .debug-count {
        font-size: 0.75rem;
        color: var(--text-muted);
    }

    .debug-controls {
        padding: var(--spacing-sm) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
    }

    .debug-log {
        max-height: 300px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.75rem;
    }

    .debug-empty {
        padding: var(--spacing-md);
        color: var(--text-muted);
        text-align: center;
    }

    .debug-entry {
        padding: var(--spacing-xs) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        gap: var(--spacing-sm);
    }

    .debug-entry:last-child {
        border-bottom: none;
    }

    .debug-entry.error {
        background: rgba(220, 53, 69, 0.1);
        color: var(--status-error);
    }

    .debug-time {
        color: var(--text-muted);
        min-width: 100px;
    }

    .debug-type {
        font-weight: 600;
        min-width: 180px;
        color: var(--color-lagoon);
    }

    .debug-entry.error .debug-type {
        color: var(--status-error);
    }

    .debug-message {
        flex: 1;
        word-break: break-word;
    }
</style>

@code {
    [Parameter] public string SessionId { get; set; } = string.Empty;

    private ClaudeSession? _session;
    private string _inputMessage = string.Empty;
    private PermissionMode _selectedPermissionMode = PermissionMode.BypassPermissions;
    private ElementReference _messagesContainer;
    private HubConnection? _hubConnection;
    private string? _signalRError;

    // Debug mode for SignalR event logging
    private bool _debugMode = false;
    private List<DebugLogEntry> _debugLog = new();
    private const int MaxDebugLogEntries = 100;

    private void LogDebug(string eventType, string message)
    {
        if (_debugMode)
        {
            _debugLog.Add(new DebugLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = eventType,
                Message = message
            });
            // Keep log size bounded
            while (_debugLog.Count > MaxDebugLogEntries)
            {
                _debugLog.RemoveAt(0);
            }
        }
    }

    private void ToggleDebugMode()
    {
        _debugMode = !_debugMode;
        if (!_debugMode)
        {
            _debugLog.Clear();
        }
        StateHasChanged();
    }

    private void ClearDebugLog()
    {
        _debugLog.Clear();
        StateHasChanged();
    }

    private class DebugLogEntry
    {
        public DateTime Timestamp { get; init; }
        public required string EventType { get; init; }
        public required string Message { get; init; }
    }

    /// <summary>
    /// Gets the assistant message for the current turn (the one that comes after the last real user message).
    /// Creates a new assistant message if one doesn't exist for the current turn.
    /// Note: Tool result messages (role=user but only ToolResult content) are NOT turn boundaries.
    /// </summary>
    private ClaudeMessage? GetOrCreateCurrentTurnAssistantMessage()
    {
        if (_session == null) return null;

        // Find the index of the last REAL user message (not a tool_result message)
        // A real user message has text content, while tool_result messages only have ToolResult content
        var lastUserMessageIndex = -1;
        for (int i = _session.Messages.Count - 1; i >= 0; i--)
        {
            var msg = _session.Messages[i];
            if (msg.Role == ClaudeMessageRole.User && IsRealUserMessage(msg))
            {
                lastUserMessageIndex = i;
                break;
            }
        }

        // Look for an assistant message AFTER the last real user message
        ClaudeMessage? currentAssistantMessage = null;
        if (lastUserMessageIndex >= 0)
        {
            for (int i = lastUserMessageIndex + 1; i < _session.Messages.Count; i++)
            {
                if (_session.Messages[i].Role == ClaudeMessageRole.Assistant)
                {
                    currentAssistantMessage = _session.Messages[i];
                    break;
                }
            }
        }
        else
        {
            // No user message yet, so any assistant message is for the current turn (initial response)
            currentAssistantMessage = _session.Messages.LastOrDefault(m => m.Role == ClaudeMessageRole.Assistant);
        }

        // If no assistant message for this turn exists, create one
        if (currentAssistantMessage == null)
        {
            currentAssistantMessage = new ClaudeMessage
            {
                SessionId = SessionId,
                Role = ClaudeMessageRole.Assistant,
                Content = []
            };
            _session.Messages.Add(currentAssistantMessage);
            LogDebug("CreateMessage", "Created new assistant message for current turn");
        }

        return currentAssistantMessage;
    }

    /// <summary>
    /// Determines if a user message is a "real" user message (with text input) vs a tool_result message.
    /// Tool result messages have role=user but only contain ToolResult content blocks.
    /// </summary>
    private static bool IsRealUserMessage(ClaudeMessage message)
    {
        if (message.Role != ClaudeMessageRole.User) return false;

        // If the message has no content, treat it as a real user message (edge case)
        if (message.Content.Count == 0) return true;

        // If all content blocks are ToolResult, this is NOT a real user message
        var hasOnlyToolResults = message.Content.All(c => c.Type == ClaudeContentType.ToolResult);
        return !hasOnlyToolResults;
    }

    /// <summary>
    /// Scrolls the messages container to the bottom.
    /// </summary>
    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval",
                $"document.querySelector('.messages-container')?.scrollTo(0, document.querySelector('.messages-container')?.scrollHeight || 0)");
        }
        catch
        {
            // Ignore scroll errors
        }
    }

    protected override async Task OnInitializedAsync()
    {
        _session = SessionService.GetSession(SessionId);

        if (_session != null)
        {
            try
            {
                await SetupSignalR();
            }
            catch (Exception ex)
            {
                // SignalR connection failed - this can happen when accessing via external hostname
                // that the container can't resolve. Continue without real-time updates.
                _signalRError = $"Real-time updates unavailable: {ex.Message}";
                Console.WriteLine($"SignalR connection failed: {ex.Message}");
            }
        }
    }

    private async Task SetupSignalR()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(SignalRUrlProvider.GetHubUrl("/hubs/claudecode"))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<ClaudeMessage>("MessageReceived", (message) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("MessageReceived", $"Role: {message.Role}, ContentBlocks: {message.Content.Count}");

                    if (_session == null) return;

                    // For user messages, check by ID
                    if (message.Role == ClaudeMessageRole.User)
                    {
                        var existingUser = _session.Messages.FirstOrDefault(m => m.Id == message.Id);
                        if (existingUser == null)
                        {
                            _session.Messages.Add(message);
                        }
                    }
                    else if (message.Role == ClaudeMessageRole.Assistant)
                    {
                        // For assistant messages, check if we already have one for this turn
                        // (created by streaming events). If so, don't add duplicate.
                        // Note: tool_result messages (role=user but only ToolResult content) are NOT turn boundaries.
                        var lastUserIndex = -1;
                        for (int i = _session.Messages.Count - 1; i >= 0; i--)
                        {
                            var msg = _session.Messages[i];
                            if (msg.Role == ClaudeMessageRole.User && IsRealUserMessage(msg))
                            {
                                lastUserIndex = i;
                                break;
                            }
                        }

                        ClaudeMessage? existingAssistant = null;
                        if (lastUserIndex >= 0)
                        {
                            for (int i = lastUserIndex + 1; i < _session.Messages.Count; i++)
                            {
                                if (_session.Messages[i].Role == ClaudeMessageRole.Assistant)
                                {
                                    existingAssistant = _session.Messages[i];
                                    break;
                                }
                            }
                        }

                        if (existingAssistant == null)
                        {
                            // No existing assistant message for this turn, add the new one
                            _session.Messages.Add(message);
                        }
                        // If existingAssistant exists, we keep it (it has streaming content) and ignore this duplicate
                    }
                    StateHasChanged();
                    await ScrollToBottom();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"MessageReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in MessageReceived: {ex.Message}");
                }
            });
        });

        _hubConnection.On<ClaudeMessageContent>("ContentBlockReceived", (content) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("ContentBlockReceived", $"Type: {content.Type}, Index: {content.Index}, TextLen: {content.Text?.Length ?? 0}");

                    // Get the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();
                    if (currentMessage != null)
                    {
                        // Check if we already have a block with this index (from streaming)
                        var existingBlock = content.Index >= 0
                            ? currentMessage.Content.FirstOrDefault(c => c.Index == content.Index)
                            : currentMessage.Content.FirstOrDefault(c => c.Type == content.Type && c.Text == content.Text);

                        if (existingBlock == null)
                        {
                            // No existing block, add this one
                            currentMessage.Content.Add(content);
                        }
                        else
                        {
                            // Block exists from streaming, just mark it as not streaming anymore
                            existingBlock.IsStreaming = false;
                        }
                    }
                    StateHasChanged();
                    await ScrollToBottom();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"ContentBlockReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in ContentBlockReceived: {ex.Message}");
                }
            });
        });

        // Handle streaming content events - now with index tracking for robust block management
        _hubConnection.On<ClaudeMessageContent, int>("StreamingContentStarted", (content, index) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("StreamingContentStarted", $"Type: {content.Type}, Index: {index}");
                    Console.WriteLine($"[SignalR] StreamingContentStarted: Type={content.Type}, Index={index}");

                    // Get or create the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();

                    // Add the streaming content block with its index
                    if (currentMessage != null)
                    {
                        // Check if we already have a block with this index
                        var existingBlock = index >= 0
                            ? currentMessage.Content.FirstOrDefault(c => c.Index == index)
                            : currentMessage.Content.FirstOrDefault(c => c.IsStreaming && c.Type == content.Type);

                        if (existingBlock == null)
                        {
                            content.Index = index;
                            currentMessage.Content.Add(content);
                        }
                    }
                    StateHasChanged();
                    await ScrollToBottom();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"StreamingContentStarted: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in StreamingContentStarted: {ex.Message}");
                }
            });
        });

        _hubConnection.On<ClaudeMessageContent, string, int>("StreamingContentDelta", (content, delta, index) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("StreamingContentDelta", $"Type: {content.Type}, Index: {index}, DeltaLen: {delta.Length}");

                    // Get the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();

                    // Find and update the streaming content block by index (more robust than type matching)
                    var streamingBlock = index >= 0
                        ? currentMessage?.Content.FirstOrDefault(c => c.IsStreaming && c.Index == index)
                        : currentMessage?.Content.LastOrDefault(c => c.IsStreaming && c.Type == content.Type);

                    if (streamingBlock != null)
                    {
                        // Apply the delta
                        switch (content.Type)
                        {
                            case ClaudeContentType.Text:
                            case ClaudeContentType.Thinking:
                                streamingBlock.Text = (streamingBlock.Text ?? "") + delta;
                                break;
                            case ClaudeContentType.ToolUse:
                                streamingBlock.ToolInput = (streamingBlock.ToolInput ?? "") + delta;
                                break;
                        }
                    }
                    StateHasChanged();
                    await ScrollToBottom();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"StreamingContentDelta: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in StreamingContentDelta: {ex.Message}");
                }
            });
        });

        _hubConnection.On<ClaudeMessageContent, int>("StreamingContentStopped", (content, index) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("StreamingContentStopped", $"Type: {content.Type}, Index: {index}");
                    Console.WriteLine($"[SignalR] StreamingContentStopped: Type={content.Type}, Index={index}");

                    // Get the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();

                    // Mark the content block as no longer streaming (find by index for robustness)
                    var streamingBlock = index >= 0
                        ? currentMessage?.Content.FirstOrDefault(c => c.IsStreaming && c.Index == index)
                        : currentMessage?.Content.LastOrDefault(c => c.IsStreaming && c.Type == content.Type);

                    if (streamingBlock != null)
                    {
                        streamingBlock.IsStreaming = false;
                    }
                    StateHasChanged();
                    await ScrollToBottom();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"StreamingContentStopped: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in StreamingContentStopped: {ex.Message}");
                }
            });
        });

        _hubConnection.On<string, ClaudeSessionStatus>("SessionStatusChanged", (sessionId, status) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionStatusChanged", $"Status: {status}");

                    if (_session != null && _session.Id == sessionId)
                    {
                        _session.Status = status;
                        StateHasChanged();
                    }
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionStatusChanged: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionStatusChanged: {ex.Message}");
                }
            });
        });

        _hubConnection.On<string>("SessionStopped", (sessionId) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionStopped", $"SessionId: {sessionId}");

                    if (_session != null && _session.Id == sessionId)
                    {
                        _session.Status = ClaudeSessionStatus.Stopped;
                        StateHasChanged();
                    }
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionStopped: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionStopped: {ex.Message}");
                }
            });
        });

        _hubConnection.On<string, decimal, long>("SessionResultReceived", (sessionId, cost, duration) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionResultReceived", $"Cost: ${cost:F6}, Duration: {duration}ms");

                    if (_session != null && _session.Id == sessionId)
                    {
                        _session.TotalCostUsd = cost;
                        _session.TotalDurationMs = duration;
                        StateHasChanged();
                    }
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionResultReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionResultReceived: {ex.Message}");
                }
            });
        });

        // Handle session state sync - sent when joining a session to catch up on any missed events
        _hubConnection.On<ClaudeSession>("SessionState", (session) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionState", $"Messages: {session.Messages.Count}, Status: {session.Status}");

                    if (_session != null && session.Id == _session.Id)
                    {
                        // Sync state from server - this handles the race condition where
                        // events may have been sent between StartAsync and JoinSession
                        // Messages is init-only, so we clear and add instead of reassigning
                        _session.Messages.Clear();
                        foreach (var msg in session.Messages)
                        {
                            _session.Messages.Add(msg);
                        }
                        _session.Status = session.Status;
                        _session.TotalCostUsd = session.TotalCostUsd;
                        _session.TotalDurationMs = session.TotalDurationMs;
                        Console.WriteLine($"[SignalR] SessionState received: {session.Messages.Count} messages, status: {session.Status}");
                    }
                    StateHasChanged();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionState: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionState: {ex.Message}");
                }
            });
        });

        await _hubConnection.StartAsync();
        await _hubConnection.SendAsync("JoinSession", SessionId);
        // Server sends SessionState after JoinSession, which we now handle above
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_inputMessage) || _session == null)
            return;

        var message = _inputMessage;
        _inputMessage = string.Empty;

        try
        {
            await SessionService.SendMessageAsync(SessionId, message, _selectedPermissionMode);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task StopSession()
    {
        if (_session == null) return;

        try
        {
            await SessionService.StopSessionAsync(SessionId);
            _session.Status = ClaudeSessionStatus.Stopped;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error stopping session: {ex.Message}");
        }
    }

    private static string GetModeBadgeClass(SessionMode mode) => mode switch
    {
        SessionMode.Plan => "bg-status-info",
        SessionMode.Build => "bg-status-success",
        _ => "bg-basalt-light"
    };

    private static string GetStatusBadgeClass(ClaudeSessionStatus status) => status.ToBadgeClass();

    private static string GetContentBlockClass(ClaudeContentType type) => type switch
    {
        ClaudeContentType.Text => "text-block",
        ClaudeContentType.Thinking => "thinking-block",
        ClaudeContentType.ToolUse => "tool-use-block",
        ClaudeContentType.ToolResult => "tool-result-block",
        _ => ""
    };

    private static string FormatDuration(long ms)
    {
        if (ms < 1000) return $"{ms}ms";
        if (ms < 60000) return $"{ms / 1000.0:F1}s";
        return $"{ms / 60000.0:F1}m";
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            try
            {
                if (_hubConnection.State == HubConnectionState.Connected)
                {
                    await _hubConnection.SendAsync("LeaveSession", SessionId);
                }
            }
            catch
            {
                // Ignore errors when leaving session - connection may already be closed
            }

            await _hubConnection.DisposeAsync();
        }
    }
}
